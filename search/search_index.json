{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to m0ccal Modular 0-Cost C Abstraction Language Motivation C is my favorite language for its speed, pointer magic, and (relative) simplicity. C is also my least favorite language for its runtime errors, having a single namespace, and terrible support for libraries. I think there is some room for improvement by creating a programming language with these specs . The first version of the transpiler should be somewhat simple with potential to make more complex features while the language's complexity remains the same. Desired Final Result A language with C's speed and control without its difficulty A language with extremely simple syntax Only the bare essential syntax is allowed Anyone that is a week into learning programming should be able to look at an arbitrary program and know what it does (given the author used good naming conventions) The complexity that is required to solve hard problems should be implemented in the standard/user libraries as classes and functions A language that has a (pretty much) 0% chance to encounter runtime errors Anything that could possibly throw an error should throw its error at compile time If it is possible for the program to access an index outside of an array, throw an error This will require a complex guarantee/assumption/proof system in the compiler This should also make the programming language extremely safe and fast The compiler should have an option (undecided if opt-in or opt-out yet) that gives extremely verbose error messages A language that is platform independent A language that integrates efficient testing and documentation constructs A language designed for modularity and a strong package ecosystem A language that works with the programmer to modularize and test things probably should be implemented in IDEs or interactive compiler/debugger Good and Bad features to include/exclude from other languages Good Python Magic methods for operators (allowing overloading) Arbitrary length Arrays and Strings and arbitrary precision Integers and Floats Inefficient, but really help in some real-world problems Multiple inheritance Class and Function nesting C Speed Manual memory management m0ccal compiler will handle this via GC Good support for bit hacking algos Preprocessor directives Java Designed for modularity Ability to easily modify code that is already compiled allow calling m0ccal code like an api while respecting access specifiers Allows method overloading based on arg types (I think) SML Pattern matching Bad Python dynamic typing C Syntax can be hard to read Runtime errors Java Slightly too verbose Import system and generics seem trash I have to have 4 different versions to run 4 different programs","title":"Welcome to m0ccal"},{"location":"#welcome-to-m0ccal","text":"Modular 0-Cost C Abstraction Language","title":"Welcome to m0ccal"},{"location":"#motivation","text":"C is my favorite language for its speed, pointer magic, and (relative) simplicity. C is also my least favorite language for its runtime errors, having a single namespace, and terrible support for libraries. I think there is some room for improvement by creating a programming language with these specs . The first version of the transpiler should be somewhat simple with potential to make more complex features while the language's complexity remains the same.","title":"Motivation"},{"location":"#desired-final-result","text":"A language with C's speed and control without its difficulty A language with extremely simple syntax Only the bare essential syntax is allowed Anyone that is a week into learning programming should be able to look at an arbitrary program and know what it does (given the author used good naming conventions) The complexity that is required to solve hard problems should be implemented in the standard/user libraries as classes and functions A language that has a (pretty much) 0% chance to encounter runtime errors Anything that could possibly throw an error should throw its error at compile time If it is possible for the program to access an index outside of an array, throw an error This will require a complex guarantee/assumption/proof system in the compiler This should also make the programming language extremely safe and fast The compiler should have an option (undecided if opt-in or opt-out yet) that gives extremely verbose error messages A language that is platform independent A language that integrates efficient testing and documentation constructs A language designed for modularity and a strong package ecosystem A language that works with the programmer to modularize and test things probably should be implemented in IDEs or interactive compiler/debugger","title":"Desired Final Result"},{"location":"#good-and-bad-features-to-includeexclude-from-other-languages","text":"","title":"Good and Bad features to include/exclude from other languages"},{"location":"#good","text":"Python Magic methods for operators (allowing overloading) Arbitrary length Arrays and Strings and arbitrary precision Integers and Floats Inefficient, but really help in some real-world problems Multiple inheritance Class and Function nesting C Speed Manual memory management m0ccal compiler will handle this via GC Good support for bit hacking algos Preprocessor directives Java Designed for modularity Ability to easily modify code that is already compiled allow calling m0ccal code like an api while respecting access specifiers Allows method overloading based on arg types (I think) SML Pattern matching","title":"Good"},{"location":"#bad","text":"Python dynamic typing C Syntax can be hard to read Runtime errors Java Slightly too verbose Import system and generics seem trash I have to have 4 different versions to run 4 different programs","title":"Bad"},{"location":"problems/","text":"Problems Things the transpiler should handle Checking syntax and access specifiers Keeping track of possible values of variables and verifying guarantees Making the unordered program use C's ordering requirements Managing memory The compiler should figure out the last possible place an object can be referenced Use this information to efficiently handle dynamic memory allocations Use bump allocation and arenas? Since everything is handled at compile time, try to perform some memoization? Probably a problem for later. Handling naming collisions and overloading Do not allow $ in function names in m0ccal When converting to C, use $ where needed so that naming collisions are impossible Throw meaningful error messages Performing a basically 1:1 mapping to C and calling the correct C compiler(s)","title":"Problems"},{"location":"problems/#problems","text":"","title":"Problems"},{"location":"problems/#things-the-transpiler-should-handle","text":"Checking syntax and access specifiers Keeping track of possible values of variables and verifying guarantees Making the unordered program use C's ordering requirements Managing memory The compiler should figure out the last possible place an object can be referenced Use this information to efficiently handle dynamic memory allocations Use bump allocation and arenas? Since everything is handled at compile time, try to perform some memoization? Probably a problem for later. Handling naming collisions and overloading Do not allow $ in function names in m0ccal When converting to C, use $ where needed so that naming collisions are impossible Throw meaningful error messages Performing a basically 1:1 mapping to C and calling the correct C compiler(s)","title":"Things the transpiler should handle"},{"location":"specs/","text":"Specs Implementation As the name suggests, m0ccal will be implemented simply as a higher-level abstraction of C. This should preserve C's efficiency while allowing better abstraction and modularity To achieve this, the current plan is to design a transpiler that simply converts m0ccal directly to an efficient C implementation after ensuring the program respects syntax, access specifiers, and guarantees. Paradigm m0ccal will be a mostly object oriented language where functions are not first-class citizens It will be very similar to Java but with slightly less verbose syntax, no generics in the traditional sense, the ability to write statements outside of classes, and not having to put all files in the same directory and name them the same as classes. Basic Syntax Allow unordered programming (can call/access before declared/defined) Built-in garbage collection Allow public, private, and protected Assume static or non static from whether or not a function uses this Can only access instance variables using this , but this is never an argument in function headers Strong, inferred typing using let Multiple inheritance without generics Everything inherits from Object even Integer, Float, and String Functions accept their arg types and anything that inherits from their arg types: class List: function append(Object obj){ /* accepts an object of any type since everything inherits from Object */ } function append(Int int){ /* Whichever parent class is the closest to the passed object will be used */ } Basis m0ccal will be based on blocking constructs: // pythonic class class Test: pass pass pass and // Javic class class Test2 {} should both be valid blocks in m0ccal. You should be able to switch between pythonic and Javic syntax Notice that pythonic syntax does not care about indentation changes within a block as long as the indention level of a statement does not fall below the indention level of the first statement in that block Valid Blocks class block class Test{} function block function Test{} C block C {} Directly inline C code Most of the language's complexity is in libraries rather than in the compiler It is up to library writers to ensure safety, speed, and platform independence in the core libraries struct block struct Test{} A class block that does not get translated. Instead assumes that a C block already implements the class using the correct naming standard. Allows the compiler to integrate C and m0ccal code seamlessly api block api testFunc{} A function block that does not get translated. Instead assumes that a C block already implements the function using the correct naming standard. Allows the compiler to integrate C and m0ccal code seamlessly Should probably design this to where it can have guarantees and assumptions in it testcase block |{} debug block !{} (LVL 1 debug) !!{} (LVL 2 debug) !!!{} (LVL 3 debug) !!!!{} (LVL 4 debug) !!!!!{} (LVL 5 debug) guarantee block *{} (moment guarantee) If it is possible for any statement within to evaluate false, throw a compiler error **{} (scope guarantee) For the rest of this scope, if it is possible for any statement within to evaluate false, throw a compiler error ***{} (forever guarantee) For the rest of the program, if it is possible for any statement within to evaluate false, throw a compiler error assumption block ~{} (moment assumption) Assume that everything inside this block evaluates to true ~~{} (scope assumption) For the rest of this scope, assume that everything inside this block evaluates to true ~~~{} (forever assumption) For the rest of the program, assume that everything inside this block evaluates to true &{} (documentation block) Not sure I actually like this idea since there are already comments. Could be documentation that survives being converted to linkable object file or something. pattern/match An SML-like pattern matching block (match multiple variables at once) Guarantee motivating example class BankAccount: let this.balance = 0.0 // guarantee that there is no way // for anything to cause the balance to // go negative ***: this.balance >= 0.0 This syntax is subject to change since one might need to guarantee something about certain indices in an array In theory, this makes it impossible to ship out an executable with a bug that allows a negative balance Problem with guarantee If given some functions f(), g(x), and h(x) s.t. g(x) needs the guarantee that h(x) == True, then for the code segment: // requires that h(f()) cannot be false let result = g(f()) The compiler must be able to prove that f() can only generate output s.t. h(f()) is true This is obviously going to be difficult (but not impossible) to write even a decent mathematical proving system just for this feature. In some cases, might run into the halting problem trying to prove by counterexample Just throw an error if whatever proof system is in place cannot verify the guarantee Suggest editing the code to look like this: function f(){ ... // Assume that the result satisfies h(result) == true ~: h(result) } function g(Object x){ *: h(x) ... } function h(Object x){ ... } or offload the work to runtime like this: function f(){ ... } function g(Object x){ if h(x): ... else: // put code here to handle when constraint fails } function h(Object x){ ... } The assumption block defeats the purpose of the guarantee block in cases where the proof system cannot prove the guarantee stands implicitly (hurts the safety of the program) As a best practice, you should only make assumptions when you are absolutely certain it is true For example: f = generate prime from sieve, h = isprime, and g is a function that requires a prime number. It is safe to assume that f() will only generate numbers x such that isprime(x) == true","title":"Specs"},{"location":"specs/#specs","text":"","title":"Specs"},{"location":"specs/#implementation","text":"As the name suggests, m0ccal will be implemented simply as a higher-level abstraction of C. This should preserve C's efficiency while allowing better abstraction and modularity To achieve this, the current plan is to design a transpiler that simply converts m0ccal directly to an efficient C implementation after ensuring the program respects syntax, access specifiers, and guarantees.","title":"Implementation"},{"location":"specs/#paradigm","text":"m0ccal will be a mostly object oriented language where functions are not first-class citizens It will be very similar to Java but with slightly less verbose syntax, no generics in the traditional sense, the ability to write statements outside of classes, and not having to put all files in the same directory and name them the same as classes.","title":"Paradigm"},{"location":"specs/#basic-syntax","text":"Allow unordered programming (can call/access before declared/defined) Built-in garbage collection Allow public, private, and protected Assume static or non static from whether or not a function uses this Can only access instance variables using this , but this is never an argument in function headers Strong, inferred typing using let Multiple inheritance without generics Everything inherits from Object even Integer, Float, and String Functions accept their arg types and anything that inherits from their arg types: class List: function append(Object obj){ /* accepts an object of any type since everything inherits from Object */ } function append(Int int){ /* Whichever parent class is the closest to the passed object will be used */ }","title":"Basic Syntax"},{"location":"specs/#basis","text":"m0ccal will be based on blocking constructs: // pythonic class class Test: pass pass pass and // Javic class class Test2 {} should both be valid blocks in m0ccal. You should be able to switch between pythonic and Javic syntax Notice that pythonic syntax does not care about indentation changes within a block as long as the indention level of a statement does not fall below the indention level of the first statement in that block","title":"Basis"},{"location":"specs/#valid-blocks","text":"class block class Test{} function block function Test{} C block C {} Directly inline C code Most of the language's complexity is in libraries rather than in the compiler It is up to library writers to ensure safety, speed, and platform independence in the core libraries struct block struct Test{} A class block that does not get translated. Instead assumes that a C block already implements the class using the correct naming standard. Allows the compiler to integrate C and m0ccal code seamlessly api block api testFunc{} A function block that does not get translated. Instead assumes that a C block already implements the function using the correct naming standard. Allows the compiler to integrate C and m0ccal code seamlessly Should probably design this to where it can have guarantees and assumptions in it testcase block |{} debug block !{} (LVL 1 debug) !!{} (LVL 2 debug) !!!{} (LVL 3 debug) !!!!{} (LVL 4 debug) !!!!!{} (LVL 5 debug) guarantee block *{} (moment guarantee) If it is possible for any statement within to evaluate false, throw a compiler error **{} (scope guarantee) For the rest of this scope, if it is possible for any statement within to evaluate false, throw a compiler error ***{} (forever guarantee) For the rest of the program, if it is possible for any statement within to evaluate false, throw a compiler error assumption block ~{} (moment assumption) Assume that everything inside this block evaluates to true ~~{} (scope assumption) For the rest of this scope, assume that everything inside this block evaluates to true ~~~{} (forever assumption) For the rest of the program, assume that everything inside this block evaluates to true &{} (documentation block) Not sure I actually like this idea since there are already comments. Could be documentation that survives being converted to linkable object file or something. pattern/match An SML-like pattern matching block (match multiple variables at once)","title":"Valid Blocks"},{"location":"specs/#guarantee-motivating-example","text":"class BankAccount: let this.balance = 0.0 // guarantee that there is no way // for anything to cause the balance to // go negative ***: this.balance >= 0.0 This syntax is subject to change since one might need to guarantee something about certain indices in an array In theory, this makes it impossible to ship out an executable with a bug that allows a negative balance","title":"Guarantee motivating example"},{"location":"specs/#problem-with-guarantee","text":"If given some functions f(), g(x), and h(x) s.t. g(x) needs the guarantee that h(x) == True, then for the code segment: // requires that h(f()) cannot be false let result = g(f()) The compiler must be able to prove that f() can only generate output s.t. h(f()) is true This is obviously going to be difficult (but not impossible) to write even a decent mathematical proving system just for this feature. In some cases, might run into the halting problem trying to prove by counterexample Just throw an error if whatever proof system is in place cannot verify the guarantee Suggest editing the code to look like this: function f(){ ... // Assume that the result satisfies h(result) == true ~: h(result) } function g(Object x){ *: h(x) ... } function h(Object x){ ... } or offload the work to runtime like this: function f(){ ... } function g(Object x){ if h(x): ... else: // put code here to handle when constraint fails } function h(Object x){ ... } The assumption block defeats the purpose of the guarantee block in cases where the proof system cannot prove the guarantee stands implicitly (hurts the safety of the program) As a best practice, you should only make assumptions when you are absolutely certain it is true For example: f = generate prime from sieve, h = isprime, and g is a function that requires a prime number. It is safe to assume that f() will only generate numbers x such that isprime(x) == true","title":"Problem with guarantee"},{"location":"syntax/","text":"Syntax Primitives EVERYTHING (including primitives) is an object Float Int String Lines Semicolons are optional Required to separate multiple statements on the same line Within pythonic blocks, the scope ends when the indention level falls below the indention level of the first statement Extra whitespace does not matter (in most cases) Preprocessor Directives // requires ./test.ccal #import test // requires ../../testing.ccal #import ..testing // something like this for archive/object files #link test Only import once to prevent circular imports Use imports as if they are classes let result = ..testing.Test(); There is no from or as for imports There are use as statments to replace this Other directives can be added later if needed Use-as // assume test.ccal has a class named TestClass with function testFunc #import test use tc as test.TestClass.testFunc; tc(); Basically an alias that is scope aware (happens after preprocessing) C blocks Literally just inline C code. Needs to be ignored by most of the compilation process and just inserted into the resulting C code. Classes protected class Test extends Test1, Test2: pass Pretty standard Functions protected function testFunc(Int input1, String input2) -> ReturnType: return ReturnType() Also pretty standard The arrow syntax might need to change Also might want to assume the function keyword for less verbosity ADITIONAL SYNTAX COMING SOON","title":"Syntax"},{"location":"syntax/#syntax","text":"","title":"Syntax"},{"location":"syntax/#primitives","text":"EVERYTHING (including primitives) is an object Float Int String","title":"Primitives"},{"location":"syntax/#lines","text":"Semicolons are optional Required to separate multiple statements on the same line Within pythonic blocks, the scope ends when the indention level falls below the indention level of the first statement Extra whitespace does not matter (in most cases)","title":"Lines"},{"location":"syntax/#preprocessor-directives","text":"// requires ./test.ccal #import test // requires ../../testing.ccal #import ..testing // something like this for archive/object files #link test Only import once to prevent circular imports Use imports as if they are classes let result = ..testing.Test(); There is no from or as for imports There are use as statments to replace this Other directives can be added later if needed","title":"Preprocessor Directives"},{"location":"syntax/#use-as","text":"// assume test.ccal has a class named TestClass with function testFunc #import test use tc as test.TestClass.testFunc; tc(); Basically an alias that is scope aware (happens after preprocessing)","title":"Use-as"},{"location":"syntax/#c-blocks","text":"Literally just inline C code. Needs to be ignored by most of the compilation process and just inserted into the resulting C code.","title":"C blocks"},{"location":"syntax/#classes","text":"protected class Test extends Test1, Test2: pass Pretty standard","title":"Classes"},{"location":"syntax/#functions","text":"protected function testFunc(Int input1, String input2) -> ReturnType: return ReturnType() Also pretty standard The arrow syntax might need to change Also might want to assume the function keyword for less verbosity","title":"Functions"},{"location":"syntax/#aditional-syntax-coming-soon","text":"","title":"ADITIONAL SYNTAX COMING SOON"},{"location":"unknowns/","text":"Unknowns Stuff that isn't fully figured out just yet Package manager, maintaining, and deprecating Should be in a way that makes it simple to install packages Need maintenance and auditing to make packages official Creating linkable files For now can just require all source files, but having some kind of archive format would be good for modifying a program after its release Needs to respect access specifiers, guarantees, assumptions, and platform independence Exact memory management algorithm Want to use arenas/bump pointers for extreme speed Since the compiler should know a lot of information about the program at compile time, it should be able to leverage this to make memory management as quick as possible. For now can just literally just malloc and free until a better algorithm is done","title":"Unknowns"},{"location":"unknowns/#unknowns","text":"","title":"Unknowns"},{"location":"unknowns/#stuff-that-isnt-fully-figured-out-just-yet","text":"Package manager, maintaining, and deprecating Should be in a way that makes it simple to install packages Need maintenance and auditing to make packages official Creating linkable files For now can just require all source files, but having some kind of archive format would be good for modifying a program after its release Needs to respect access specifiers, guarantees, assumptions, and platform independence Exact memory management algorithm Want to use arenas/bump pointers for extreme speed Since the compiler should know a lot of information about the program at compile time, it should be able to leverage this to make memory management as quick as possible. For now can just literally just malloc and free until a better algorithm is done","title":"Stuff that isn't fully figured out just yet"}]}